---
title: "Plots"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install.packages("BiocManager")
#BiocManager::install("Seurat")
#BiocManager::install("ggplot2")
#BiocManager::install("sctransform")

library(Seurat)
library(ggplot2)
library(dplyr)
library(ape)
library(cowplot)
library(Matrix)
library(EnhancedVolcano)

#find out where you are
getwd()

#Specify where your matrix files are
dir= "/Users/whippoorwill/Desktop/Sequencing/LD_AVM02/"
datafolder = "Data/Seurat"
filename = "Microglia_BC_Macrophages_subset.RData"
organism = "Mouse"
defile = "Macrophage_only_all_markers.csv"

if(organism == "Mouse"){library(org.Mm.eg.db)}
if(organism == "Human"){library(org.Hs.eg.db)}
if(organism == "Zebrafish"){library(org.Dr.eg.db)}
```
Load in your filtered dataset
```{r}
load(file.path(dir,datafolder,filename))
```

Other differential expression methods: 

1. Compare each cluster to one "baseline" cluster
```{r}
base = '0'                 #default cluster
column = "seurat_clusters" #can pick any metadata column
```


```{r,eval = F, results = "hide"}
Idents(sobject) = column
clusters = levels(sobject@meta.data[,column]) 
clusters = clusters[clusters != base]

for (cluster in clusters){
  markers_all <- FindMarkers(
    object = sobject,
    ident.1 = cluster,
    ident.2 = base,
    only.pos = FALSE, 
    min.pct = 0.10, #gene must be present in 10% of the cells in the cluster
    logfc.threshold = 0,
    test.use = "MAST")
  dim(markers_all)
  head(markers_all)
  write.csv(markers_all,file = file.path(dir,"Spreadsheets",paste0("markers",cluster,"_vs_",base,".csv")))
}
```

Or you can run "bulk-seq" like analyses based on your original sample IDs: 

```{r}
#can pick any metadata column
column = "sample_description"
#default cluster
cluster1 = 'Deprived-P5'    
#cluster of interest
cluster2 = "Control-P5"
```

```{r,results = "hide", eval = FALSE}
Idents(sobject) = column
markers = FindMarkers(sobject,
                      ident.1=cluster1,
                      ident.2 = cluster2,
                      only.pos=F,
                      logfc.threshold = 0.0,
                      min.pct = 0.1,
                      test.use = "MAST")
write.csv(markers,file.path(dir,"Spreadsheets",paste0("markers_",cluster1,"_vs_",cluster2,".csv")))
```

You can also make plots with only subsets of cells: Best for making umap plots where both conditions/individuals have equal representation. 
```{r}
#first check how many cells are in each group so you don't pick a number more than the min
column = "sample_description"
ncells = 2000
genes = c("Cx3cr1","P2ry12","Spp1","Nrxn2","Ifitm3","Mki67","Pf4")
features = m
categories = c("sample_description","age","condition","celltypecluster")
name = "macrophage_equalcells"
```

Function to print multiple graphs: 
```{r}
PrintSeuratGraph = function(namecard = "a",seurat_object = sobject,graphtype = "feature",feature = NULL,group = NULL,split=NULL,cellnames=NULL){
  if (!is.null(cellnames)){
    Idents(seurat_object) = cellnames[1]
    cells = colnames(seurat_object)[Idents(seurat_object) %in% cellnames[2:length(cellnames)]]} 
  else {cells = cellnames}
  if (graphtype == "feature"){
    graph = FeaturePlot(seurat_object,features = feature,split.by = split, cells = cells,cols = c("lightyellow","darkred"))
  }
  if (graphtype == "violin"){
    graph = VlnPlot(seurat_object,features = feature, pt.size = 0.1, idents = cellnames[2:length(cellnames)],group.by = group, split.by = split)
  }
  if (graphtype == "dim"){
    graph = DimPlot(seurat_object,cells = cells, group.by = group, split.by = split)
    
  }
  name = paste0(feature,"_",graphtype,namecard,".eps")
  graph
  setEPS()
  postscript(file.path(dir,Plotfolder,name))
  print(graph)
  dev.off()
}
```

```{r}
table(sobject$sample_description)
cellnames = sobject@meta.data[,column]
names(cellnames) = colnames(sobject)
groups = levels(cellnames)

newcellnames = NULL
for (group in groups){
  cells = sample((cellnames)[cellnames == group],ncells)
  newcellnames = c(newcellnames,cells)
}

#feature plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "feature",feature = feature,cellnames = newcellnames)
}

#split feature plots by individual
for(feature in c(features)){
  PrintSeuratGraph(namecard = paste0(name,"_split"),graphtype = "feature",feature = feature,split = "sample_description",cellnames = newcellnames)
}

#dim plots for clustering
for(group in categories){
  PrintSeuratGraph(namecard = name,graphtype = "dim",group = group, feature = group,cellnames = newcellnames)
}

#violin plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "violin",feature = feature,group = "seurat_clusters",cellnames = newcellnames)
}
```


You can save umap and pc embeddings to load into other programs like Loupe and anything in Python like scvelo (velocity)
```{r}
#Edit name only if one project has multiple embeddings
name = paste0(Project(sobject),"_",name)
```


```{r}
#Save umap embeddings
umap =as.data.frame(sobject@reductions$umap@cell.embeddings)
umap$Cellname = rownames(umap)
umap = umap[,order(colnames(umap))]
write.csv(umap,file = file.path(dir,"Annotation",paste0(name,"_umap_embed.csv")),row.names = F)

#save pcs
pc =as.data.frame(sobject@reductions$pc@cell.embeddings)
pc$Cellname = rownames(pc)
pc = pc[,order(colnames(pc))]
write.csv(pc,file = file.path(dir,"Annotation",paste0(name,"_pc_embed.csv")),row.names = F)

#save metadata
meta = sobject@meta.data
meta$Cellname = rownames(meta)
meta = meta[,c(ncol(meta),1:(ncol(meta)-1))]
write.csv(pc,file = file.path(dir,"Annotation",paste0(name,"_metadata.csv")),row.names = F)

#For PanoView (in Python, a way to mathematically validate # of clusters found)
annotation = sobject$sample_description #or any column
x = as.matrix(GetAssayData(sobject,slot = "counts"))
x = x[rownames(x) %in% VariableFeatures(sobject),]

write.csv(x,file = file.path(dir,"Annotation",paste0(name,"_counts.csv")))
write.csv(annotation,file = file.path(dir,"Annotation",paste0(name,"_annotation.csv")))
```

You can add annotations from the annotationDB database: 
```{r}
de = read.csv(file.path(dir,"Spreadsheets",defile),stringsAsFactors = F) #any spreadsheet with gene symbols or other identifiers
```

```{r}
if (organism == "Mouse"){db = org.Mm.eg.db}
if (organism == "Human"){db = org.Hs.eg.db}
if (organism == "Zebrafish"){db = org.Dr.eg.db}

ids=de$gene 
fromKey="SYMBOL" #must match the ids - could also be ensembl ID
toKey=c("GENENAME","ENSEMBL","UNIPROT") #whatever annotation you want to add - find with keytypes(db)
selRes<-AnnotationDbi::select(db,keys=ids,keytype=fromKey,columns=c(fromKey,toKey))

x=selRes[match(ids,selRes[,1]),1:(length(toKey)+1)]
identical(x$SYMBOL,de$gene)
de$GeneName = x$GENENAME
de$Ensembl = x$ENSEMBL
de$Uniprot = x$UNIPROT
```

*Volcano Plot*

Set your parameters
```{r}
#Minimum fold change (i.e. 1.15 = 15% increase)
minfc = 1.15
#Max adj. p value
alpha = 1e-25
#Clusters selected
categories = levels(as.factor(de$cluster))
#Genes to highlight
ngenes = 20
```

Set up the spreadsheet correctly
```{r}
colnames(de)[8] = "Gene"
newlist = list()
clusters = levels(as.factor(de$cluster))

#Split by cluster
i = 1
for (cluster in clusters){
  newlist[[cluster]] = de[de$cluster == cluster,]
  i = i+1
}

#select a single cluster

for (category in categories){
  fc = newlist[[category]]
  fc = fc[!is.na(fc$avg_logFC),]
  colorkeysdown = fc$Gene[fc$avg_logFC < -log2(minfc) & fc$p_val_adj < alpha]
  colorkeysup = fc$Gene[fc$avg_logFC > log2(minfc) & fc$p_val_adj < alpha]

#Either highlight specific genes or pick the top genes in colorkeysup/down
  top = fc[fc$p_val_adj<alpha,]
  top = top[order(top$avg_logFC),"Gene"]
  highlight = c(head(top,ngenes),tail(top,ngenes))

  allcolors = rep("darkgrey",length(fc$Gene))
  names(allcolors) = fc$Gene

  allcolors[names(allcolors) %in% colorkeysdown] = "blue"
  allcolors[names(allcolors) %in% colorkeysup]= "red"
  allcolors[names(allcolors) %in% highlight]= "yellow"

  names(allcolors)[allcolors == "yellow"] = "labelled"
  names(allcolors)[allcolors == "red"] = "u"
  names(allcolors)[allcolors == "darkgrey"] = "-"
  names(allcolors)[allcolors == "blue"] = "d"
  
  setEPS()
  postscript(file.path(dir,"Plots",paste0("Volcano_",category,".eps")))
  print(EnhancedVolcano(fc,
                lab = fc$Gene,
                x = 'avg_logFC',
                y = 'p_val_adj',
                xlim = c(-3, 3),
                title = category,
                subtitle = "",
                drawConnectors = F,
                legendPosition = 'right',
                legendVisible = F,
                pCutoff = alpha,
                FCcutoff = log2(minfc),
                selectLab = highlight,
                transcriptPointSize = 1.5,
                transcriptLabSize = 2.0,
                col=c('black', 'black', 'black', 'red3'),
                colCustom = allcolors,
                gridlines.major = F,
                gridlines.minor = F,
                colAlpha = 1))
  dev.off()

  print(EnhancedVolcano(fc,
                lab = fc$Gene,
                x = 'avg_logFC',
                y = 'p_val_adj',
                xlim = c(-3, 3),
                title = category,
                subtitle = "",
                drawConnectors = F,
                legendPosition = 'right',
                legendVisible = F,
                pCutoff = alpha,
                FCcutoff = log2(minfc),
                selectLab = highlight,
                transcriptPointSize = 1.5,
                transcriptLabSize = 2.0,
                col=c('black', 'black', 'black', 'red3'),
                colCustom = allcolors,
                gridlines.major = F,
                gridlines.minor = F,
                colAlpha = 1))

}

```

You can find what phase of the cell cycle each cell is in: 

Cell cycle regression specifically for mouse genes right now - can adjust slightly for human/zebrafish data by changing the capitalization of the spreadsheet

```{r}
cc.genes <- readLines(con = "../Spreadsheets/regev_lab_cell_cycle_genes.txt")
genesofinterest = c("Pcna","Top2a","Mcm6","Mki67")

#for zebrafish and mice, change gene names to lowercase
if (organism %in% c("Zebrafish","Mouse")){cc.genes<-tolower(cc.genes)}

#for mice, capitalize the first letter of each gene
if (organism == "Mouse"){
  cc.genes<-unname(sapply(cc.genes,function(x){
    x<-paste0(toupper(substr(x,start = 1,stop = 1)),substring(x,first=2))
    }))
}

#assign each gene to "S" phase or "G2M" phase
s.genes <- cc.genes[1:43]
g2m.genes <- cc.genes[44:97]

#score each cell by gene expression on this subset of genes
sobject <- CellCycleScoring(object = sobject, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)

# view cell cycle scores and phase assignments
head(x = sobject@meta.data)
RidgePlot(object = sobject, features = genesofinterest)
FeaturePlot(sobject,"S.Score")
FeaturePlot(sobject,"G2M.Score")

#save phase plot
setEPS()
postscript(file.path(dir,"Plots",paste0(name,"_phasechart.eps")))
DimPlot(sobject,group.by = "Phase")
dev.off()
```


```{r,eval = FALSE}
#save seurat object with cell cycle scoring
save(sobject,file = file.path(dir,datafolder,filename)))
```


You can regress out the phase genes
```{r,eval = FAlSE}
regress = c("S.Score","G2M.Score","nCount_RNA","percent.mito")
columns = c("sample_description","seurat_clusters","celltypecluster","condition","age","Phase")

#run PCA on only the cell cycle genes
sobject2 <- RunPCA(object = sobject, pc.genes = c(s.genes, g2m.genes), do.print = FALSE, maxit=10000)

#cell cycle only
PCAPlot(object = sobject2)

#original
PCAPlot(object = sobject)

#regress out cell cycle variables
sobject2 <- ScaleData(object = sobject2, features = VariableFeatures(sobject), vars.to.regress = regress)

# Now, a PCA on the variable genes no longer returns components associated
# with cell cycle
sobject2 <- RunPCA(object = sobject2, features = VariableFeatures(sobject), genes.print = 10)
PCAPlot(object = sobject2)

#remake umap with new calculations without cell cycle
sobject2@reductions$UMAP<-NULL
sobject2<-RunUMAP(sobject2,reduction = "pca",dims = 1:30, verbose = F)
sobject2<-FindNeighbors(sobject2,dims=1:30,verbose=F)
set.seed(1)
sobject2<-FindClusters(sobject2,verbose=F,resolution = 0.5)
```

```{r}
load(file.path(dir,datafolder, paste0(name,"_cellcycleregressed.RData")))
```

```{r}
#make plots without cell cycle
for (column in columns){
  print(DimPlot(object = sobject2, group.by=column, pt.size=0.5,label = T))
}
```


```{r,eval = FALSE}
#save seurat object with cell cycle scoring
save(sobject2,file = file.path(dir,datafolder,paste0(name,"_cellcycleregressed.RData")))
```


Barplot for any two (or more) categories

```{r}
#Pick metadata columns
clustercolumn = "seurat_clusters"
samplecolumn = "sample_description"
#pick a reasonable number of cells per sample to normalize by
ncells = 2000 
cols = c("blue","red")
#If you want to only compare particular samples/conditions, split further by another metadata column: 
split = "age"
```


```{r}
splitby = levels(as.factor(sobject[[split]][,1]))

#Make a table and normalize
r = table(sobject[[clustercolumn]][,1],sobject[[samplecolumn]][,1])

#Split the table
for (i in splitby){
  x = grep(i,colnames(r))
  t = r[,x]
  
  #remove any clusters that don't have cells
  t = t[rowSums(t)>0,]
  
  #normalize by sample
  t = apply(t,MARGIN = 2,function(x)x/sum(x))
  t = round(t*ncells,0)
  
  #convert to percents for each cluster
  t = apply(t,MARGIN = 1,function(x)x/sum(x))
  t = round(t*100,2)
  
  setEPS()
  postscript(file.path(dir,"Plots",paste0(name,i,"barplot.eps")))
  barplot(t, main="Cluster composition by percent of celltype",
        xlab="Cluster", ylab = "% of cluster", ylim = c(0,100), col=cols,axisnames = T,
        width = .2,xlim = c(0,5),legend = rownames(t), space = 0.6,cex.names = 0.8,axis.lty = 1)
  dev.off()
  print(barplot(t, main="Cluster composition by percent of celltype",
        xlab="Cluster", ylab = "% of cluster", ylim = c(0,100), col=cols,axisnames = T,
        width = .2,xlim = c(0,5),legend = rownames(t), space = 0.6,cex.names = 0.8,axis.lty = 1))

}
```

 Contingency tables for barplots. Note that this makes more sense if done with only 2 samples, as only one statistic will be calculated per cluster. 
 
```{r}
clustercolumn = "seurat_clusters"
samplecolumn = c("sample_description")
```

```{r}
all = table(sobject[[clustercolumn]][,1],sobject[[samplecolumn]][,1])
array = as.data.frame(cbind("Cluster" = 1, "Sample1" = 1, "Sample2" = 1, "p-value" = 1, "Cramer's V" =1))
for (i in 1:(ncol(all)-1)){
  for (k in (i+1):ncol(all)){
    partial = all[,c(i,k)]
    total = colSums(partial)
    clusters = rownames(partial)
    test = list()
    chi = chisq.test(partial)

    for (cluster in clusters){
      x = rbind(partial[cluster,],total-partial[cluster,])
      rownames(x) = c(cluster,"total")
      chi = chisq.test(x)
      f = sqrt(chi$statistic/sum(x))
      test[[cluster]] = chi
      test[[cluster]]$f = f
      
      pval = test[[cluster]]$p.value
      Cramer = sqrt(test[[cluster]]$statistic/sum(all[cluster,]))
      out = c(cluster,colnames(partial),pval,Cramer)
      #print out the p-value and cramer's v (closer to 1 = higher effect size) for each cluster
      array = rbind(array,out)
    }
  }
  array = array[2:nrow(array),]
}

array
write.csv(array,file = file.path(dir,"Spreadsheets",paste0(name,"_contingency.csv")),row.names = T,quote = F)
```
 