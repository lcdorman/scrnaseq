---
title: "Seurat_Code_QC_2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Begin by installing and loading necessary packages. Unhash the "install" script if you need to install them. You only need to install once per machine, unless you want to update. 

```{r}
#install.packages("BiocManager")
#BiocManager::install("Seurat")
#BiocManager::install("ggplot2")
#BiocManager::install("sctransform")
```

Load packages into your workspace. 

```{r}
library(Seurat)
library(ggplot2)
#library(sctransform)
library(dplyr)
library(ape)
#library(variancePartition)
library(cowplot)
library(Matrix)
#library(magrittr)
#find out where you are
getwd()
```

*Edit the following code every time*
```{r}
#Specify your preferred directory for all input + output
dir= "/Users/whippoorwill/Desktop/Sequencing/LD_AVM02"

#Specify exactly where your matrix files/raw data live
datafolder = "Data/CellRanger"


#Add in any folder name within each sample that leads to your data files: 
innerfolder = "filtered_feature_bc_matrix"
#Specify what kind of data you have: "CellRanger" Output (barcodes + matrix .tsv files) or "counts" data (usually something ending in counts.tsv)
datatype = "CellRanger"

#if "datatype" = "counts", specify "filename", otherwise "NA" or "NULL"
filename = "GEX_counts.tsv.gz"

#Set minimums for genes/cell (min.features) and cell expressing a given gene (min.cells). Default is 1/1, you can filter later. If the object is very large, filter here. 
min.cells = 1
min.features = 1

#Name your project something descriptive
project<-"Microglia_BC" 

#Specify your organism; please capitalize the first letter (i.e. "Mouse", "Human","Zebrafish","Rat")
organism = "Mouse"

```


Then create an object with the folder names that you can use to open each sample folder when you need it. The following code will allow you to open all the folders in sequence. 
```{r}
ids = list.files(file.path(dir,datafolder))
ids
```
*Edit this as well*

Assign meaningful identities to each sample, or load in a csv file
```{r}
names = ids
age = c(rep("P5",2),rep("P7",2))
condition = c("Deprived","Control","Deprived","Control")
sample_description = paste0(condition,"-",age)
meta = as.data.frame(cbind(age,condition,sample_description))
rownames(meta) = ids
meta
```

For each ID (i.e. folder), read in the data and change the colomn names to look like: "Barcode - id". If the second chunk doesn't work, try manually unzipping the file. Make sure to change the 'filename' extension above. 
```{r}
if (datatype == "CellRanger"){
  d10x.data = sapply(ids, function(id){
    d10x = Read10X(file.path(dir,datafolder,id,innerfolder)) #read in each matrix
    colnames(d10x) = paste(sapply(strsplit(colnames(d10x),split="-"),'[[',1L),id,sep="-") 
    d10x
  })
}

if (datatype == "counts"){
  d10x.data = sapply(ids, function(id){
    d10x =as.sparse(read.table(file.path(dir,datafolder,id,filename),sep = '\t',header = T,row.names = 1))
    colnames(d10x) = paste(sapply(strsplit(colnames(d10x),split="-"),'[[',1L),id,sep="-")
    d10x
  })
}
```

The d10x.data object is a list of arrays whose columns consist of cell IDs and whose rows represent genes. 
Make experiment.data, a single array with as many columns as total cells. 

```{r}
experiment.data<-do.call("cbind",d10x.data)
```

"Aggregate" the data which cellRanger can do, but not well. Create a seurat object, keeping genes that are in >3 cells, cells with >50 genes (you can always set these to zero and filter later)

"names.field" and "names.delim" determines the input identity for each sample. IE if the cells are named "barcode - id", the "name" for each sample (listed in orig.ident) will be id.  

```{r}
sobject <- CreateSeuratObject(
        experiment.data,
        project = project, 
        min.cells = min.cells, 
        min.features = min.features, 
        names.field = 2, #put the "id" from above into meta data
        names.delim = "\\-")

table(sobject$orig.ident)
```

Calculate mitochondrial and ribosomal content, add as metadata to each cell (column). Percent mito is literally dividing one matrix by another matrix to get a percentage. Grep searches through rownames of the data (i.e. genes) for anything that starts with mt. 

```{r}
if (organism %in% c("Mouse","Rat")){
  sobject <- PercentageFeatureSet(sobject, pattern = "^mt-", col.name = "percent.mito")
  sobject <- PercentageFeatureSet(sobject, pattern = "^Rp", col.name = "percent.ribo")
}
if (organism == "Human"){
  sobject <- PercentageFeatureSet(sobject, pattern = "^MT-", col.name = "percent.mito")
  sobject <- PercentageFeatureSet(sobject, pattern = "^RP", col.name = "percent.ribo")
}
if (organism == "Zebrafish"){
  sobject <- PercentageFeatureSet(sobject, pattern = "^mt-", col.name = "percent.mito")
  sobject <- PercentageFeatureSet(sobject, pattern = "^rp", col.name = "percent.ribo")
}
```

Note that the metadata column "orig.ident" always holds your sample IDs (i.e. the names of the data folders). Don't overwrite it. 

Add sample descriptions as metadata columns.

```{r}
samplename = as.character(sobject$orig.ident)
names(samplename) = names(sobject$orig.ident)

#replace the names with any column of "meta" - add anything to meta and the following if necessary
age = sapply(samplename,function(x)meta[x,"age"])
condition = sapply(samplename,function(x)meta[x,"condition"])
sample_description = sapply(samplename,function(x)meta[x,"sample_description"])

#add new metadata columns
sobject$sample_description = sample_description
sobject$age = age
sobject$condition = condition

#check
table(sobject$sample_description,sobject$orig.ident)
table(sobject$age,sobject$condition)
table(sobject$age,sobject$sample_description)
```

For mouse/human cells, you can determine from Xist expression which ones are male and which are female. 
```{r}
if (organism %in% c("Human","Mouse","Rat")){
  if (organism == "Human") {
    sexgene = "XIST"
  } else {
    sexgene = "Xist"
  }
  genecount = GetAssayData(sobject,slot = "counts")[sexgene,]
  cells = names(genecount)
  female = genecount[genecount > 0]
  male = genecount[genecount <1]
  names(cells)[cells %in% names(female)] = "Female"
  names(cells)[cells %in% names(male)] = "Male"
  #add in a new metadata column
  sobject$sex = cells
  #Check with a violin plot
  VlnPlot(sobject,sexgene,group.by = "sex")
}

```

QC - decide on final filtering parameters, look for clear outliers/differences between samples. These are quantiles of cells. Also shows you the variability between cells (and between samples)

Function to make an annotated violin plot
```{r}
anno_vln = function(seurat_object = sobject, metric = "nCount_RNA", group = "orig.ident"){
  #specify number of categories
  n = length(levels(seurat_object@meta.data[,group]))

  #make a violin plot
  a = VlnPlot(seurat_object,metric,group.by = group,pt.size = 0,log = F,cols = rep("grey",n))

  #make a simple function that quantifies percentiles for each column
  add.percentiles = function(x) {
    r = quantile(x, probs = seq(0,1,0.2))
    r
  }

  a + geom_boxplot(width = 0.05,outlier.size = 0,notchwidth = 10,notch = T) + theme_bw() + stat_summary(fun=add.percentiles, geom="point", pch="_", colour=c(rep(c("red3","purple","yellow","forestgreen","darkblue","grey"),n)), size=10)
}
```

Plot each metric
```{r}
m = c("nCount_RNA","nFeature_RNA","percent.mito","percent.ribo")
directory = "~/Desktop/QC"
#Save graphs
for (i in m){
  graph = anno_vln(metric = i)
  setEPS()
  postscript(file.path(directory,paste0(i,project,".eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in m){
  graph = anno_vln(metric = i)
  print(graph)
}
```


Plot the number of cells each gene is represented by - i.e. how many cells express any given gene? Ordered from rare to common genes. So you might consider focusing on genes that are relatively well expressed across the sample, or you might care about genes expressed only in a small subset of cells. The >=2 refers to read number per cell. 
```{r}
plot(sort(Matrix::rowSums(GetAssayData(sobject)>=2)),xlab="gene rank",ylab="number of cells",main="Cells per genes ( >= 2 )")
```
Gene Plot, scatter plot of gene expression across cells, (colored by sample) - sequencing depth relative to genes; looking for similarity across samples. Some cell types can have relatively few genes, but highly expressed, could show up as a second arc below the one seen here (should contain all samples though)
```{r}
Idents(sobject) = "sample_description"
m = c("nCount_RNA","nFeature_RNA","percent.mito","percent.ribo")

directory = "~/Desktop/QC"
#Save graphs
for (i in 1:(length(m)-1)){
  graph = FeatureScatter(sobject,m[i],m[i+1])+ theme_bw()
  setEPS()
  postscript(file.path(directory,paste0(m[i],"_",m[i+1],project,"scatter.eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in 1:(length(m)-1)){
  graph = FeatureScatter(sobject,m[i],m[i+1])+ theme_bw()
  print(graph)
}
```
Set limits based on the graphs
```{r}
mlo = -0.1
mhi = 10
clo = 1200
chi = 15000
flo = 500
fhi = 3000
rlo = 0
rhi = 70
```

Violin plot of 1) number of genes, 2) number of UMI and 3) percent mitochondrial genes; save with lines that show cutoffs

```{r}
group = "sample_description"
#Make a table with your cutoff values
m = c("nFeature_RNA","nCount_RNA","percent.mito","percent.ribo")
tablelow = c(flo,clo,mlo,rlo)
tablehigh = c(fhi,chi,mhi,rhi)
t = as.data.frame(rbind(tablelow,tablehigh))
colnames(t) = m


#Save graphs
directory = "~/Desktop/QC"
for (i in 1:ncol(t)){
  metric = colnames(t)[i]
  low = t[1,i]
  high = t[2,i]
  graph = anno_vln(metric = metric) + geom_abline(intercept = high, slope = 0, linetype = "dashed",color = "red", size = 0.8) + geom_abline(intercept = low, slope = 0, linetype = "dashed",color = "black", size = .8)
  setEPS()
  postscript(file.path(directory,paste0(colnames(t)[i],project,"withcutoffs.eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in 1:ncol(t)){
   metric = colnames(t)[i]
  low = t[1,i]
  high = t[2,i]
  graph = anno_vln(metric = metric) + geom_abline(intercept = high, slope = 0, linetype = "dashed",color = "red", size = 0.8) + geom_abline(intercept = low, slope = 0, linetype = "dashed",color = "black", size = .8)
  print(graph)
}

```


Scatter plots with lines to show cutoffs
```{r}
t
directory = "~/Desktop/QC"
#Save graphs
for (i in 1:(length(colnames(t))-1)){
  xm = colnames(t)[i]
  ym = colnames(t)[i+1]
  xlow = t[1,i]
  xhigh = t[2,i]
  ylow = t[1,i+1]
  yhigh = t[2,i+1]
  graph = FeatureScatter(sobject,xm,ym)+ theme_bw() + geom_vline(xintercept = xlow, linetype = "dashed",color = "black", size = .8) + geom_vline(xintercept = xhigh, linetype = "dashed",color = "red", size = .8)+ geom_hline(yintercept = ylow, linetype = "dashed",color = "black", size = .8)  + geom_hline(yintercept = yhigh, linetype = "dashed",color = "red", size = .8)
  setEPS()
  postscript(file.path(directory,paste0(m[i],"_",m[i+1],project,"scatter_withcutoffs.eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in 1:(length(colnames(t))-1)){
  xm = colnames(t)[i]
  ym = colnames(t)[i+1]
  xlow = t[1,i]
  xhigh = t[2,i]
  
  ylow = t[1,i+1]
  yhigh = t[2,i+1]
  
  graph = FeatureScatter(sobject,xm,ym)+ theme_bw() + geom_vline(xintercept = xlow, linetype = "dashed",color = "black", size = .8) + geom_vline(xintercept = xhigh, linetype = "dashed",color = "red", size = .8)+ geom_hline(yintercept = ylow, linetype = "dashed",color = "black", size = .8)  + geom_hline(yintercept = yhigh, linetype = "dashed",color = "red", size = .8)
  print(graph)
}
```


Filtering cells: note that they are taking these filters and duplicating them across all samples. Use -Inf instead of 0 because not all the filters have to be positive values, and to avoid any errors due to truncation. 

How to select filters??? noise vs signal - get them from the violin plots and the matrix, capture the bulk of cells but exclude outliers (say with mtDNA filter) - can also look at percentiles, maybe get rid of top 5% since it was very different from the rest. Basically eliminate outliers and don't include cells that have hardly any genes or have a ton of genes expressed. First save the original object: 

```{r}
directory = "~/Desktop/Sequencing/Nick/2_2020/NickData"
#save(sobject,file = file.path(directory,"afterQC.RData"))
```


