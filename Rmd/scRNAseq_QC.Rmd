---
title: "Seurat_Code_QC_2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Begin by installing and loading necessary packages. Unhash the "install" script if you need to install them. You only need to install once per machine, unless you want to update. 

```{r}
#install.packages("BiocManager")
#BiocManager::install("Seurat")
#BiocManager::install("ggplot2")
#BiocManager::install("sctransform")
```

Load packages into your workspace. 

```{r}
library(Seurat)
library(ggplot2)
#library(sctransform)
library(dplyr)
library(ape)
#library(variancePartition)
library(cowplot)
library(Matrix)
#library(magrittr)
#find out where you are
getwd()
```

*Edit the following code every time*
```{r}
#Specify your preferred directory for all input + output
dir= "/Users/whippoorwill/Desktop/Sequencing/LD_AVM02"

#Specify exactly where your matrix files/raw data live
datafolder = "Data/CellRanger"


#Add in any folder name within each sample that leads to your data files: 
innerfolder = "filtered_feature_bc_matrix"
#Specify what kind of data you have: "CellRanger" Output (barcodes + matrix .tsv files) or "counts" data (usually something ending in counts.tsv)
datatype = "CellRanger"

#if "datatype" = "counts", specify "filename", otherwise "NA" or "NULL"
filename = "GEX_counts.tsv.gz"
```


Then create an object with the folder names that you can use to open each sample folder when you need it. The following code will allow you to open all the folders in sequence. 
```{r}
ids = list.files(file.path(dir,datafolder))
ids
```

For each ID (i.e. folder), read in the data and change the colomn names to look like: "Barcode - id". If the second chunk doesn't work, try manually unzipping the file. Make sure to change the 'filename' extension above. 
```{r}
if (datatype == "CellRanger"){
  d10x.data = sapply(ids, function(id){
    d10x = Read10X(file.path(dir,datafolder,id,innerfolder)) #read in each matrix
    colnames(d10x) = paste(sapply(strsplit(colnames(d10x),split="-"),'[[',1L),id,sep="-") 
    d10x
  })
}

if (datatype == "counts"){
  d10x.data = sapply(ids, function(id){
    d10x =as.sparse(read.table(file.path(dir,datafolder,id,filename),sep = '\t',header = T,row.names = 1))
    colnames(d10x) = paste(sapply(strsplit(colnames(d10x),split="-"),'[[',1L),id,sep="-")
    d10x
  })
}
```

The d10x.data object is a list of arrays whose columns consist of cell IDs and whose rows represent genes. 
Make experiment.data into an array with each element of d10x.data (which is a list) as columns (as many columns as cells per sample)
This creates a new array that contains all of the cells and genes from d10x.data but puts them in one array instead of many. 

```{r}
experiment.data<-do.call("cbind",d10x.data)
```

"Aggregate" the data which cellRanger does, but not well. Create a seurat object, keeping genes that are in >3 cells, cells with >50 genes (you can always set these to zero and filter later)

All of the following fields can be altered. I am not filtering by cells or features; the "names.field" and "names.delim" determines the input identity for each cell. 

```{r}
project<-"Leah" #Name this anything you want
colnames(experiment.data)[1:5] #look at cell name structure

sobject <- CreateSeuratObject(
        experiment.data,
        project = project, 
        min.cells = 3, #minimum cells each gene is present in
        min.features = 50, #minimum genes per cell
        names.field = 2, #put the "id" from above into meta data
        names.delim = "\\-")
table(sobject$orig.ident)
```

Calculate mitochondrial content, add as metadata to each cell (column). Percent mito is literally dividing one matrix by another matrix to get a percentage. Grep searches through rownames of the data (i.e. genes) for anything that starts with mt. 

```{r}
sobject <- PercentageFeatureSet(sobject, pattern = "^mt-", col.name = "percent.mito")
sobject <- PercentageFeatureSet(sobject, pattern = "^Rp", col.name = "percent.ribo")
```

Extract the sampleIDs which are stored in "orig.ident". The numbers are numbers of cells (columns). Orig.ident is defined by the file from which the data was isolated. 

```{r}
samplename = as.factor(sobject$orig.ident)
table(samplename)
```

add sample descriptions to the column (cell) names for each sample. if you call a name of a cell you can see which sample it's from

```{r}
#check that the names are levels
levels(samplename)

#rename to whatever you like, in order
levels(samplename) = c("Juvenile A","Adult A","Adult B","Juvenile B") 
table(samplename)

#add new metadata column
sobject$sample_description = samplename

#check
table(sobject$sample_description,sobject$orig.ident)

#Add in any other metadata
age = sobject$sample_description
levels(age) = c("Juvenile","Adult","Adult","Juvenile")
sobject$age = age

individual = sobject$sample_description
levels(individual) = c("A","A","B","B")
sobject$individual = individual
```

For mouse/human cells, you can determine from Xist expression which ones are male and which are female. 
```{r}
sexgenes = c("g0s2","ptprc") #normally set to Xist and Tsix
sex = GetAssayData(sobject,slot = "counts")[sexgenes,]

#now you have a 2-row array with a number of counts per cell; split by whether counts are >1 or <1
female = sex[,sex[1,]>1 & sex[2,] > 1]

#get all the cell names from your seurat object
cells = colnames(sobject)
names(cells) = rep("Male",length(cells))
names(cells)[cells %in% colnames(female)] = "Female"

fm = names(cells)
table(fm)

#add in a new metadata column
sobject$sex = fm

#Check with a violin plot
VlnPlot(sobject,sexgenes,group.by = "sex")
```

QC - decide on final filtering parameters, look for clear outliers/differences between samples. These are quantiles of cells. Also shows you the variability between cells (and between samples)

Function to make an annotated violin plot
```{r}
anno_vln = function(seurat_object = sobject, metric = "nCount_RNA", group = "orig.ident"){
  #specify number of categories
  n = length(levels(seurat_object@meta.data[,group]))

  #make a violin plot
  a = VlnPlot(seurat_object,metric,group.by = group,pt.size = 0,log = F,cols = rep("grey",n))

  #make a simple function that quantifies percentiles for each column
  add.percentiles = function(x) {
    r = quantile(x, probs = seq(0,1,0.2))
    r
  }

  a + geom_boxplot(width = 0.05,outlier.size = 0,notchwidth = 10,notch = T) + theme_bw() + stat_summary(fun=add.percentiles, geom="point", pch="_", colour=c(rep(c("red3","purple","yellow","forestgreen","darkblue","grey"),n)), size=10)
}
```

Plot each metric
```{r}
m = c("nCount_RNA","nFeature_RNA","percent.mito","percent.ribo")
directory = "~/Desktop/QC"
#Save graphs
for (i in m){
  graph = anno_vln(metric = i)
  setEPS()
  postscript(file.path(directory,paste0(i,project,".eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in m){
  graph = anno_vln(metric = i)
  print(graph)
}
```


Plot the number of cells each gene is represented by - i.e. how many cells express any given gene? Ordered from rare to common genes. So you might consider focusing on genes that are relatively well expressed across the sample, or you might care about genes expressed only in a small subset of cells. The >=2 refers to read number per cell. 
```{r}
plot(sort(Matrix::rowSums(GetAssayData(sobject)>=2)),xlab="gene rank",ylab="number of cells",main="Cells per genes ( >= 2 )")
```
Gene Plot, scatter plot of gene expression across cells, (colored by sample) - sequencing depth relative to genes; looking for similarity across samples. Some cell types can have relatively few genes, but highly expressed, could show up as a second arc below the one seen here (should contain all samples though)
```{r}
Idents(sobject) = "sample_description"
m = c("nCount_RNA","nFeature_RNA","percent.mito","percent.ribo")

directory = "~/Desktop/QC"
#Save graphs
for (i in 1:(length(m)-1)){
  graph = FeatureScatter(sobject,m[i],m[i+1])+ theme_bw()
  setEPS()
  postscript(file.path(directory,paste0(m[i],"_",m[i+1],project,"scatter.eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in 1:(length(m)-1)){
  graph = FeatureScatter(sobject,m[i],m[i+1])+ theme_bw()
  print(graph)
}
```
Set limits based on the graphs
```{r}
mlo = -0.1
mhi = 10
clo = 1200
chi = 15000
flo = 500
fhi = 3000
rlo = 0
rhi = 70
```

Violin plot of 1) number of genes, 2) number of UMI and 3) percent mitochondrial genes; save with lines that show cutoffs

```{r}
group = "sample_description"
#Make a table with your cutoff values
m = c("nFeature_RNA","nCount_RNA","percent.mito","percent.ribo")
tablelow = c(flo,clo,mlo,rlo)
tablehigh = c(fhi,chi,mhi,rhi)
t = as.data.frame(rbind(tablelow,tablehigh))
colnames(t) = m


#Save graphs
directory = "~/Desktop/QC"
for (i in 1:ncol(t)){
  metric = colnames(t)[i]
  low = t[1,i]
  high = t[2,i]
  graph = anno_vln(metric = metric) + geom_abline(intercept = high, slope = 0, linetype = "dashed",color = "red", size = 0.8) + geom_abline(intercept = low, slope = 0, linetype = "dashed",color = "black", size = .8)
  setEPS()
  postscript(file.path(directory,paste0(colnames(t)[i],project,"withcutoffs.eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in 1:ncol(t)){
   metric = colnames(t)[i]
  low = t[1,i]
  high = t[2,i]
  graph = anno_vln(metric = metric) + geom_abline(intercept = high, slope = 0, linetype = "dashed",color = "red", size = 0.8) + geom_abline(intercept = low, slope = 0, linetype = "dashed",color = "black", size = .8)
  print(graph)
}

```


Scatter plots with lines to show cutoffs
```{r}
t
directory = "~/Desktop/QC"
#Save graphs
for (i in 1:(length(colnames(t))-1)){
  xm = colnames(t)[i]
  ym = colnames(t)[i+1]
  xlow = t[1,i]
  xhigh = t[2,i]
  ylow = t[1,i+1]
  yhigh = t[2,i+1]
  graph = FeatureScatter(sobject,xm,ym)+ theme_bw() + geom_vline(xintercept = xlow, linetype = "dashed",color = "black", size = .8) + geom_vline(xintercept = xhigh, linetype = "dashed",color = "red", size = .8)+ geom_hline(yintercept = ylow, linetype = "dashed",color = "black", size = .8)  + geom_hline(yintercept = yhigh, linetype = "dashed",color = "red", size = .8)
  setEPS()
  postscript(file.path(directory,paste0(m[i],"_",m[i+1],project,"scatter_withcutoffs.eps")))
  print(graph)
  dev.off()
}

#print graphs
for (i in 1:(length(colnames(t))-1)){
  xm = colnames(t)[i]
  ym = colnames(t)[i+1]
  xlow = t[1,i]
  xhigh = t[2,i]
  
  ylow = t[1,i+1]
  yhigh = t[2,i+1]
  
  graph = FeatureScatter(sobject,xm,ym)+ theme_bw() + geom_vline(xintercept = xlow, linetype = "dashed",color = "black", size = .8) + geom_vline(xintercept = xhigh, linetype = "dashed",color = "red", size = .8)+ geom_hline(yintercept = ylow, linetype = "dashed",color = "black", size = .8)  + geom_hline(yintercept = yhigh, linetype = "dashed",color = "red", size = .8)
  print(graph)
}
```


Filtering cells: note that they are taking these filters and duplicating them across all samples. Use -Inf instead of 0 because not all the filters have to be positive values, and to avoid any errors due to truncation. 

How to select filters??? noise vs signal - get them from the violin plots and the matrix, capture the bulk of cells but exclude outliers (say with mtDNA filter) - can also look at percentiles, maybe get rid of top 5% since it was very different from the rest. Basically eliminate outliers and don't include cells that have hardly any genes or have a ton of genes expressed. First save the original object: 

```{r}
directory = "~/Desktop/Sequencing/Nick/2_2020/NickData"
#save(sobject,file = file.path(directory,"afterQC.RData"))
```


