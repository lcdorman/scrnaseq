---
title: "Seurat_Code_PostQC_2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


```{r}
#install.packages("BiocManager")

#BiocManager::install("Seurat")
#BiocManager::install("ggplot2")
#BiocManager::install("sctransform")

library(Seurat)
library(ggplot2)
library(sctransform)
library(dplyr)
library(ape)
library(variancePartition)
library(cowplot)
library(Matrix)
library(org.Mm.eg.db)
library(org.Hs.eg.db)
library(org.Dr.eg.db)

#find out where you are
getwd()
dir= "/Users/whippoorwill/Desktop/Sequencing/Nick/2_2020"
 #set this to whatever you like, above the level of your data folder
#setwd(dir)
```
Function to print multiple graphs: 
```{r}
PrintSeuratGraph = function(namecard = "a",seurat_object = sobject,graphtype = "feature",feature = NULL,group = NULL,split=NULL,cellnames=NULL){
  if (!is.null(cellnames)){
    Idents(seurat_object) = cellnames[1]
    cells = colnames(seurat_object)[Idents(seurat_object) %in% cellnames[2:length(cellnames)]]} 
  else {cells = cellnames}
  if (graphtype == "feature"){
    graph = FeaturePlot(seurat_object,features = feature,split.by = split, cells = cells,cols = c("lightgrey","lightblue","yellow","orange","darkorange","red"))
  }
  if (graphtype == "violin"){
    graph = VlnPlot(seurat_object,features = feature, pt.size = 0.1, idents = cellnames[2:length(cellnames)],group.by = group, split.by = split)
  }
  if (graphtype == "dim"){
    graph = DimPlot(seurat_object,cells = cells, group.by = group, split.by = split)
    
  }
  name = paste0(feature,"_",graphtype,namecard,".eps")
  graph
  setEPS()
  postscript(file.path(dir,"plots",name))
  print(graph)
  dev.off()
}

```

```{r}
load(file.path(dir,"NickData/Nick2020_unfiltered.RData"))
```

Set limits based on the graphs from the QC page
```{r}
mlo = -0.1
mhi = 10
clo = 1200
chi = 15000
flo = 500
fhi = 3000
rlo = 0
rhi = 70
```

Subset the data. Printing tables lets you see the progression as you tighten your QC cutoffs. 
```{r}
print("initial")
table(sobject$sample_description) #print out initial cell counts
sobject = subset(sobject, subset = percent.mito>mlo & percent.mito < mhi) #subset mitochondria
print("mito")
table(sobject$sample_description) #new cell counts
sobject = subset(sobject, subset = nCount_RNA>clo & nCount_RNA < chi)
print("ncount")
table(sobject$sample_description)
sobject = subset(sobject, subset = nFeature_RNA>flo & nFeature_RNA < chi)
print("nfeature")
table(sobject$sample_description)
```

```{r}
save(sobject, file = file.path(dir,"sobject_filtered_umap.RData"))
```

Find variable features, normalize, scale, run PCA, clustering, umap

Include any genes that may not vary a lot but are important for downstream applications.PSA: mouse genes have the first letter capitalized; humans are fully capitalized; fish are lowercase. rownames(sobject) will help you troubleshoot. 
```{r}
add.genes = c('ptprc','lgmn','hexb','apoeb','mpeg1.1')
regress = c("nFeature_RNA")
sct = FALSE
```

The following is the standard method of normalization and scaling. Interchangeable with the next chunk. 
```{r}
if (!sct){
  sobject <- NormalizeData(sobject,normalization.method = "LogNormalize", scale.factor = 10000)

  sobject<-FindVariableFeatures(sobject, selection.method = "vst", nfeatures = 10000)
  all.genes<-rownames(sobject)
  var.genes = VariableFeatures(sobject)

  labels <- c(head(VariableFeatures(sobject),10),"cd74b","mpeg1.1","cd74a","hexb","apoeb")
  plot1 = VariableFeaturePlot(sobject)
  LabelPoints(plot=plot1, points = labels, repel = F, xnudge = 0.1, ynudge = 0.5)

  add.genes = add.genes[!add.genes %in% var.genes]
  any(add.genes %in% var.genes)
  scalegenes = c(var.genes,add.genes)

  sobject<-ScaleData(sobject,features = scalegenes, vars.to.regress = regress)
}

```

Alternative: SCTransform (great for smaller datasets)
```{r}
if (sct){
  add.genes = c("ptprc","lgmn","hexb","mpeg1.1","apoeb")
  regress = c("nFeature_RNA","percent.mito")

  sobject <- SCTransform(sobject, vars.to.regress = regress, verbose = FALSE,variable.features.n = 6000,conserve.memory = T)


  top10 <- c(head(VariableFeatures(sobject),10),"cd74b","mpeg1.1","cd74a","hexb","apoeb")
  top10 <- head(VariableFeatures(sobject),10)
  plot1 = VariableFeaturePlot(sobject)
  LabelPoints(plot=plot1, points = top10, repel = F, xnudge = 0.1, ynudge = 0.5)
}

```

Run PCA analysis
```{r}
sobject <- RunPCA(sobject,features = scalegenes,npcs = 50, verbose = FALSE)

ElbowPlot(sobject,ndims = 50, reduction = "pca")
print(sobject[["pca"]], dims = 1:20, nfeatures = 5)
```

Once you are satisfied with pc's, run clustering: 
```{r}
pcs = 1:30
sobject<-RunUMAP(sobject,reduction = "pca",dims = pcs, verbose = F)
sobject<-FindNeighbors(sobject,dims=pcs,verbose=F)

res = 0.8 #set this to anything
sobject<-FindClusters(sobject,verbose=F,resolution = res) 
```

Plot important objects; check parameters before moving forward, evaluate QC, clustering
```{r}
genes = c("mpeg1.1","apoeb","ptprc","hexb")
dims = c("seurat_clusters","sample_description","age")
QC = c("nCount_RNA","nFeature_RNA","percent.mito","percent.ribo")

for (dim in dims){
  print(DimPlot(sobject,group.by = dim, label = T))
}

FeaturePlot(sobject,genes)
FeaturePlot(sobject,QC)

VlnPlot(sobject,genes,sort = "increasing",pt.size = 0.01)

#Build a clustering tree
Idents(sobject) = "seurat_clusters"
sobject= BuildClusterTree(sobject,dims = 1:30)
tree = sobject@tools$BuildClusterTree
plot.phylo(tree, use.edge.length = T, direction = "rightwards")
```
```{r}
#If you want to see a certain cluster: 
cluster = '13'

#select only the cells from that cluster
cells = sobject$seurat_clusters
cells = cells[cells == cluster]

DimPlot(sobject,cells.highlight = names(cells))
```

If you are happy with the QC, you can move on to either subdividing further to isolate interesting cells (below) or running differential expression comparisons on the existing clustering. 

Note that the chunk below requires you to manually decide which clusters to keep or exclude. The violin plots will help decide based on marker genes. You can also choose to annotype (as many types as you want) and skip subsetting. 
```{r}
#Edit this part carefully. You can add any number of types. Each cluster can only be one type. 
type1 = c(0,1,3,5,6,7,8,9,10,15,18,19,20)
name1 = "mpeg"
type2 = c(2,4,11,12,13,14,16,17,21,22,23) 
name2 = "cd45"

#Initialize the cluster levels as a vector and replace the cluster levels with the appropriate name. 
clusters = as.factor(sobject$seurat_clusters)
type = levels(clusters)
type[type1+1] = name1
type[type2+1] = name2
levels(clusters) = type

#Add a metadata column
sobject$celltype = clusters

#check the celltype assignment for accuracy
table(sobject$celltype,sobject$seurat_clusters)

#Check them against your marker genes
markergene = c("mpeg1.1","hexb","ptprc")
VlnPlot(sobject,markergene,group.by = "celltype",pt.size = 0.01)

#add a metadata column labelling each cluster
sobject$celltypecluster = paste0(sobject$celltype,"-",sobject$seurat_clusters)

#save the unsubsetted data. This will overwrite the one you just saved because it has all the same info + celltype assigned and tree calculated. 
save(sobject,file = file.path(dir,paste0(Project(sobject),"_sobject_filtered_umap.RData")))
```

Save the tree
```{r}
Idents(sobject) = "celltypecluster"
sobject= BuildClusterTree(sobject,dims = 1:30)
tree = sobject@tools$BuildClusterTree
setEPS()
postscript(file.path(dir,"tree_iteration1.eps"))
plot.phylo(tree, use.edge.length = T, direction = "rightwards")
dev.off()
```

Block to print multiple graphs: 
```{r}
name = "juv_mpeg"
genes = c("marco","mpeg1.1","apoeb","p2ry12","ptprc","hexb","irf8","spi1b","spi1a","csf1ra","csf1rb","slc7a7","c1qa","c1qb","c1qc","cd74a","cd74b","pcna","mki67","siglec15l")
features = c("percent.mito","percent.ribo","nCount_RNA","nFeature_RNA")
groups = c("age","sample_description","seurat_clusters","celltype","celltypeclusters")
genes = genes[genes %in% rownames(GetAssayData(sobject,slot = "data"))]

#just to print to the console some nice graphs
FeaturePlot(sobject,genes[1:5])
FeaturePlot(sobject,genes[6:9])

genes = c("mcl1b")
#feature plots

for(feature in genes){
  PrintSeuratGraph(namecard = name,graphtype = "feature",feature = feature)
}

for(feature in features){
  PrintSeuratGraph(namecard = name,graphtype = "feature",feature = feature)
}

#split feature plots by individual
for(feature in c(features)){
  PrintSeuratGraph(namecard = paste0(name,"_split"),graphtype = "feature",feature = feature,split = "sample_description")
}

#dim plots for clustering
for(group in groups){
  PrintSeuratGraph(namecard = name,graphtype = "dim",group = group, feature = group)
}

#violin plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "violin",feature = feature,group = "seurat_clusters")
}
```


Subset the data to include only your celltypes of interest: 
```{r}
#edit keep to include all wanted celltypes
keep = c("mpeg")

#subset the object by the metadata column "celltype"
sobject = subset(sobject,subset = celltype %in% keep)

#check the resulting subset
table(sobject$celltype,sobject$seurat_clusters)
```
Whenever you remove cells from a seurat object, you have to re-normalize, scale, and calculate pca/umap/clustering. This is copied out from above. I'm keeping the same add.genes but of course you could change them here. 

```{r}
add.genes = c("ptprc","lgmn","hexb","mpeg1.1","apoeb")
regress = c("nFeature_RNA")

if (sct){sobject <- SCTransform(sobject, vars.to.regress = regress, verbose = FALSE,variable.features.n = 6000,conserve.memory = T)}

if (!sct){
  sobject <- NormalizeData(sobject,normalization.method = "LogNormalize", scale.factor = 10000)

  sobject<-FindVariableFeatures(sobject, selection.method = "vst", nfeatures = 10000)
  all.genes<-rownames(sobject)
  var.genes = VariableFeatures(sobject)

  add.genes = add.genes[!add.genes %in% var.genes]
  any(add.genes %in% var.genes)
  scalegenes = c(var.genes,add.genes)

  sobject<-ScaleData(sobject,features = scalegenes, vars.to.regress = regress)
}


top10 <- c(head(VariableFeatures(sobject),10),"cd74b","mpeg1.1","cd74a","hexb","apoeb")
plot1 = VariableFeaturePlot(sobject)
LabelPoints(plot=plot1, points = top10, repel = F, xnudge = 0.1, ynudge = 0.5)
```

Run PCA analysis
```{r}
sobject <- RunPCA(sobject,features = scalegenes,npcs = 50, verbose = FALSE)

ElbowPlot(sobject,ndims = 50, reduction = "pca")
print(sobject[["pca"]], dims = 1:10, nfeatures = 5)
```

Once you are satisfied with pc's, run clustering: 
```{r}
pcs = 1:30
sobject<-RunUMAP(sobject,reduction = "pca",dims = pcs, verbose = F)
sobject<-FindNeighbors(sobject,dims=pcs,verbose=F)

res = 0.3 #set this to anything
sobject<-FindClusters(sobject,verbose=F,resolution = res) 


```

Look at resulting clustering to evaluate
```{r}
genes = c("mpeg1.1","apoeb","ptprc","hexb","cd74a","cd74b","bzw2","g0s2","ctsba","lygl1")
genes[genes %in% VariableFeatures(sobject)]
dims = c("seurat_clusters","sample_description","age")
QC = c("nCount_RNA","nFeature_RNA","percent.mito","percent.ribo")

for (dim in dims){
  print(DimPlot(sobject,group.by = dim, label = T))
}

FeaturePlot(sobject,genes)
FeaturePlot(sobject,QC)

VlnPlot(sobject,genes,sort = "increasing",pt.size = 0.01)

#Build a clustering tree
Idents(sobject) = "seurat_clusters"
sobject= BuildClusterTree(sobject,dims = 1:30)
tree = sobject@tools$BuildClusterTree
plot.phylo(tree, use.edge.length = T, direction = "rightwards")
save(sobject,file = file.path(dir,paste0(Project(sobject),"_",keep,"only_umap.RData")))
```





Heatmap for clusters within this celltype
```{r}
Idents(sobject) = "seurat_clusters"
markers_all <- FindAllMarkers(
    object = sobject,
    features = rownames(sobject),
    test.use = "MAST",
    only.pos = FALSE, 
    min.pct = 0.05, #gene must be present in 5% of the cells in the cluster
    logfc.threshold = 0.20
)

#write.csv(markers_all,file = file.path(dir,"all_markers_mpeg.csv"))
```


```{r}
#set your p-value threshold
pcut = 1e-5
genespercluster = 5

#select positive markers for heatmap
markers_all = markers_all[markers_all$avg_logFC>0.2,]

#select genes that pass a p-value threshold
markers_all = markers_all[markers_all$p_val_adj<pcut,]
markers_all <- markers_all[markers_all$gene %in% names(table(markers_all$gene))[table(markers_all$gene) == 1],] #markers that define a single cluster

topgenes <- markers_all %>% group_by(cluster) %>% top_n(genespercluster, avg_logFC)

setEPS()
postscript(file.path(dir,paste0("heatmap_",keep,"_only",pcut,".eps")))
DoHeatmap(
    object = sobject, 
    features = topgenes$gene,
    group.by = 'seurat_clusters',
    size = 5,
    label = T,
    draw.lines = T
)

dev.off()
```
Heatmap for console

```{r}
DoHeatmap(
    object = sobject, 
    features = topgenes$gene,
    group.by = 'seurat_clusters',
    size = 5,
    label = T,
    draw.lines = T
)
```


```{r}
save(sobject,file = file.path(dir,paste0(keep,"_only_sctransform.RData")))
```

As this is a checkpoint, you can load in the data again if necessary: 

```{r}
load(file.path(dir,"mpeg_only_sctransform.RData"))
de = read.csv(file.path(dir,"all_markers_mpeg.csv"),stringsAsFactors = F)
head(de)
```

```{r}
genes = c("pcna","siglec15l")
DimPlot(sobject,label = T)
DimPlot(sobject,group.by = "sample_description")

FeaturePlot(sobject,genes)
VlnPlot(sobject,genes,pt.size = 0.001,sort = T)

sobject = BuildClusterTree(sobject,dims = 1:30)
PlotClusterTree(sobject)
```


```{r}
table(sobject$age,sobject$seurat_clusters)
```


```{r}
type1 = c(0,2,5,8)
name1 = "juvenile"
type2 = c(1,4,7)
name2 = "adult"
type3 = c(3)
name3 = "macrophage"
type4 = 6
name4 = "proliferating"

#Initialize the cluster levels as a vector and replace the cluster levels with the appropriate name. 
clusters = as.factor(sobject$seurat_clusters)
type = levels(clusters)
type[type1+1] = name1
type[type2+1] = name2
type[type3+1] = name3
type[type4+1] = name4
levels(clusters) = type

#Add a metadata column
sobject$celltype = clusters
sobject$celltypecluster = paste0(sobject$celltype,"-",sobject$seurat_clusters)

DimPlot(sobject,group.by = "celltypecluster",split.by = "age")
```

Block to print multiple graphs: 
```{r}
name = "all_mpeg"
genes = c("marco","mpeg1.1","apoeb","p2ry12","ptprc","hexb","irf8","spi1b","spi1a","csf1ra","csf1rb","slc7a7","c1qa","c1qb","c1qc","cd74a","cd74b","pcna","mki67","siglec15l")
features = c("percent.mito","percent.ribo","nCount_RNA","nFeature_RNA")
groups = c("age","sample_description","seurat_clusters","celltype","celltypeclusters")
genes = genes[genes %in% rownames(GetAssayData(sobject,slot = "data"))]

#just to print to the console some nice graphs
FeaturePlot(sobject,genes[1:5])
FeaturePlot(sobject,genes[6:9])

#feature plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "feature",feature = feature)
}

#split feature plots by individual
for(feature in c(features)){
  PrintSeuratGraph(namecard = paste0(name,"_split"),graphtype = "feature",feature = feature,split = "sample_description")
}

#dim plots for clustering
for(group in groups){
  PrintSeuratGraph(namecard = name,graphtype = "dim",group = group, feature = group)
}

#violin plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "violin",feature = feature,group = "seurat_clusters")
}
```

```{r}
Idents(sobject) = "celltypecluster"
sobject = BuildClusterTree(sobject,dims = c(1:30))
tree = sobject@tools$BuildClusterTree
setEPS()
postscript(file.path(dir,"tree_mpegall.eps"))
plot.phylo(tree, use.edge.length = T, direction = "rightwards")
dev.off()
```


```{r}
Idents(sobject) = "celltype"
markers_all = FindAllMarkers(
  object = sobject,
  features = rownames(sobject),
  test.use = "MAST", 
  only.pos = FALSE, 
  min.pct = 0.10, 
  logfc.threshold = 0.0)

```

```{r}
write.csv(markers_all,file = file.path(dir, "juv_v_adult_mpeg.csv"))

pcut = 1e-25
lfc = 0.2
ngenes = 5

markers_all = markers_all[markers_all$p_val_adj<pcut,]
markers_all = markers_all[markers_all$avg_logFC>lfc,]

#markers_all_single <- markers_all[markers_all$gene %in% names(table(markers_all$gene))[table(markers_all$gene) == 1],] #markers that define a single cluster

topgenes <- markers_all %>% group_by(cluster) %>% top_n(ngenes, avg_logFC)

setEPS()
postscript(file.path(dir,"heatmap_juv_v_adult_mpeg.eps"))
DoHeatmap(
    object = sobject, 
    features = topgenes$gene,
    group.by = 'celltypecluster',
    size = 5,
    label = T,
    draw.lines = T
)

dev.off()

```

Heatmap for console
```{r}
DoHeatmap(
    object = sobject, 
    features = topgenes$gene,
    group.by = 'celltypecluster',
    size = 5,
    label = T,
    draw.lines = T
)
```

Other differential expression methods: 

1. Compare each cluster to one "baseline" cluster
```{r}
base = '0'                 #default cluster
column = "seurat_clusters" #can pick any metadata column

Idents(sobject) = column
clusters = levels(sobject@meta.data[,column]) 

setwd("~/Desktop/plots")
Idents(sobject) = "seurat_clusters"
for (cluster in clusters){
  markers_all <- FindMarkers(
    object = sobject,
    ident.1 = cluster,
    ident.2 = base,
    only.pos = FALSE, 
    min.pct = 0.10, #gene must be present in 10% of the cells in the cluster
    logfc.threshold = 0,
    test.use = "MAST")
  dim(markers_all)
  head(markers_all)
  write.csv(markers_all,paste0("markers",cluster,"_vs_",base,".csv"))
}
```

Or you can run "bulk-seq" like analyses based on your original sample IDs: 

```{r}
#can pick any metadata column
column = "seurat_clusters"
#default cluster
cluster1 = '0'    
#cluster of interest
cluster2 = "2" 


Idents(sobject) = column
markers = FindMarkers(sobject,
                      ident.1=cluster1,
                      ident.2 = cluster2,
                      only.pos=F,
                      logfc.threshold = 0.0,
                      min.pct = 0.1,
                      test.use = "MAST")
write.csv(markers,file.path(dir,paste0("markers_",cluster1,"_vs_",cluster2,".csv")))
```

You can make a heatmap only including certain genes/cells: 

```{r}
#read in a de gene file
markers = read.csv("singlemarkersMG_0501.csv",stringsAsFactors = F)

#establish cutoffs
pval = 1e-8 #max p-value for significance
lfc = 0.2 #minimum log fold change
minpct = 0.3 #if you want to subset by percent cells in that cluster expressing the gene
maxpct = 0.7
single = F #should each gene be a marker of a single cluster only
ngenes = 3 #how many genes should be in the heatmap per cluster
ncells = 500 #max # of cells per heatmap column
column = "finalclusters" #division you care about

markers = markers[markers$p_val_adj<pcut,]
markers = markers[markers$avg_logFC > lfc,] #pick only positives, or restrict by min/max pct expression using pct1/2

#If you want, select markers that define a single cluster
if (single){markers <- markers[markers$gene %in% names(table(markers$gene))[table(markers$gene) == 1],] }

table(markers$cluster)

topgenes <- markers %>% group_by(cluster) %>% top_n(ngenes, avg_logFC)
topgenes = topgenes[order(topgenes$cluster),]
topgenes$gene

#Subset each cluster to ncells
cellnames = sobject@meta.data[,column]
names(cellnames) = colnames(sobject)
clusters = levels(cellnames)
newcellnames = NULL
for (cluster in clusters){
  n = length(cellnames[cellnames == cluster])
  if (n > ncells){n = ncells}
  newcluster = sample(cellnames[cellnames == cluster],n, replace = F)
  newcellnames = c(newcellnames,newcluster)
}

#check
table(newcellnames)

#Make heatmap
setEPS()
postscript(file.path(dir,paste0(column,"_",pval,"_ncells",ncells,"heatmap.eps")))
DoHeatmap(
    object = sobject, 
    features = c(topgenes$gene),
    cells = names(newcellnames),
    group.by = column,
    size = 5,
    label = T,
    draw.lines = T
)

dev.off()
```


You can also make plots with only subsets of cells: Best for making umap plots where both conditions/individuals have equal representation. 
```{r}
#first check how many cells are in each group so you don't pick a number more than the min
column = "sample_description"
ncells = 2000
genes = c("")
features = c("")
categories = c("")
name = "equalcells"
dir = ""

table(sobject$sample_description)
cellnames = sobject@meta.data[,column]
names(cellnames) = colnames(sobject)
groups = levels(cellnames)

newcellnames = NULL
for (group in groups){
  cells = sample((cellnames)[cellnames == group],ncells)
  newcellnames = c(newcellnames,cells)
}

#feature plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "feature",feature = feature,cellnames = newcellnames)
}

#split feature plots by individual
for(feature in c(features)){
  PrintSeuratGraph(namecard = paste0(name,"_split"),graphtype = "feature",feature = feature,split = "sample_description",cellnames = newcellnames)
}

#dim plots for clustering
for(group in categories){
  PrintSeuratGraph(namecard = name,graphtype = "dim",group = group, feature = group,cellnames = newcellnames)
}

#violin plots
for(feature in c(genes,features)){
  PrintSeuratGraph(namecard = name,graphtype = "violin",feature = feature,group = "seurat_clusters",cellnames = newcellnames)
}
```


You can save umap and pc embeddings to load into other programs like Loupe and anything in Python like scvelo (velocity)
```{r}
#Edit name only if one project has multiple embeddings
name = Project(sobject)
#Save umap embeddings
umap = sobject@reductions$umap@cell.embeddings
umap$Cellname = rownames(umap)
write.csv(umap,file = file.path(dir,name,"umap_embed.csv",row.names = F))

#save pcs
pc = sobject@reductions$pca@cell.embeddings
pc$Cellname = rownames(pc)
write.csv(pc,file = file.path(dir,name,"pc_embed.csv",row.names = F))

#save metadata
meta = sobject@meta.data
meta$gene = rownames(meta)
write.csv(pc,file = file.path(dir,name,"metadata.csv",row.names = F))
```

For PanoView (in Python, a way to mathematically validate # of clusters found)
```{r}
annotation = sobject$sample_description #or any column

name = Project(sobject)
x = as.matrix(GetAssayData(sobject,slot = "counts"))
x = x[rownames(x) %in% VariableFeatures(sobject),]

write.csv(x,file = file.path(dir,paste0(name,"_counts.csv")))
write.csv(annotation,file = file.path(dir,paste0(name,"_annotation.csv")))
```

You can add annotations from the annotationDB database: 
```{r}
organism = "mouse"

if (organism %in% c("Mouse","mouse","mus musculus","Mus musculus","Mm")){db = org.Mm.eg.db}
if (organism %in% c("Human","human","homo sapiens","Homo sapiens","Hs")){db = org.Hs.eg.db}
if (organism %in% c("Zebrafish","zebrafish","danio rerio","Danio rerio","Dr")){db = org.Dr.eg.db}

fc = read.csv("../Spreadsheets/allmarkers_vargenesMG_0501.csv",stringsAsFactors = F) #any spreadsheet with gene symbols or other identifiers
ids=fc$gene 
fromKey="SYMBOL" #must match the ids - could also be ensembl ID
toKey=c("GENENAME","ENSEMBL","UNIPROT") #whatever annotation you want to add - find with keytypes(db)
selRes<-AnnotationDbi::select(db,keys=ids,keytype=fromKey,columns=c(fromKey,toKey))

x=selRes[match(ids,selRes[,1]),1:(length(toKey)+1)]
identical(x$SYMBOL,fc$gene)
fc$GeneName = x$GENENAME
fc$Ensembl = x$ENSEMBL
fc$Uniprot = x$UNIPROT
```


********************
Volcano Plot: 
```{r}
de = read.csv("../Spreadsheets/allmarkers_vargenesMG_0501.csv",stringsAsFactors = F)
colnames(fc)[8] = "Gene"
```

Set your parameters
```{r}
#Minimum fold change (i.e. 1.15 = 15% increase)
minfc = 1.15

#Max adj. p value
alpha = 1e-25

#Ccluster selected
category = "4"
```

```{r}
colnames(de)[8] = "Gene"
newlist = list()
clusters = levels(as.factor(de$cluster))

#Split by cluster
i = 1
for (cluster in clusters){
  newlist[[cluster]] = de[de$cluster == cluster,]
  i = i+1
}

#select a single cluster
fc = newlist[[category]]
fc = fc[!is.na(fc$avg_logFC),]
colorkeysdown = fc$Gene[fc$avg_logFC < -log2(minfc) & fc$p_val_adj < alpha]
colorkeysup = fc$Gene[fc$avg_logFC > log2(minfc) & fc$p_val_adj < alpha]
```



```{r}
allcolors = rep("darkgrey",length(fc$Gene))
names(allcolors) = fc$Gene
a = c(sample(colorkeysdown,10),sample(colorkeysup,10))

allcolors[names(allcolors) %in% colorkeysdown] = "blue"
allcolors[names(allcolors) %in% colorkeysup]= "red"
allcolors[names(allcolors) %in% a]= "brown"

names(allcolors)[allcolors == "brown"] = "labelled"
names(allcolors)[allcolors == "red"] = "u"
names(allcolors)[allcolors == "darkgrey"] = "-"
names(allcolors)[allcolors == "blue"] = "d"
```

Make the plot
  
```{r}
setEPS()
postscript(file.path(dir,paste0("plots_Volcano_",category,".eps")))
EnhancedVolcano(fc,
                lab = fc$Gene,
                x = 'avg_logFC',
                y = 'p_val_adj',
                xlim = c(-3, 3),
                title = category,
                subtitle = "",
                drawConnectors = F,
                legendPosition = 'right',
                legendVisible = F,
                pCutoff = alpha,
                FCcutoff = log2(minfc),
                selectLab = a,
                transcriptPointSize = 1.5,
                transcriptLabSize = 2.0,
                col=c('black', 'black', 'black', 'red3'),
                colCustom = allcolors,
                gridlines.major = F,
                gridlines.minor = F,
                colAlpha = 1)
dev.off()

```

You can find what phase of the cell cycle each cell is in: 

Cell cycle regression

```{r}
cc.genes <- readLines(con = "../Spreadsheets/regev_lab_cell_cycle_genes.txt")
cc.genes<-tolower(cc.genes)
cc.genes<-unname(sapply(cc.genes,function(x){x<-paste0(toupper(substr(x,1,1)),substring(x,first=2))}))
s.genes <- cc.genes[1:43]
g2m.genes <- cc.genes[44:97]


mgAVM02 <- CellCycleScoring(object = sobject, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)

# view cell cycle scores and phase assignments
head(x = mgAVM02@meta.data)

RidgePlot(object = mgAVM02, features = c("Pcna", "Top2a", "Mcm6", "Mki67"))
FeaturePlot(mgAVM02,"S.Score")
FeaturePlot(mgAVM02,"G2M.Score")

setEPS()
postscript(file.path(dir,"phasechart.eps"))
DimPlot(mgAVM02,group.by = "Phase")
dev.off()

save(mgAVM02,file = file.path(dir,paste0(Project(sobject),".RData")))
```


*************
```{r}
sobject2 <- RunPCA(object = sobject, pc.genes = c(s.genes, g2m.genes), do.print = FALSE, maxit=10000)
PCAPlot(object = sobject2)
PCAPlot(object = sobject)
var.genes = c(VariableFeatures(sobject2),'Fcrls', 'Olfml3', 'Lgmn', 'Cx3cr1','Hexb')
var.genes = var.genes[!var.genes %in% c('Xist', 'Gm47283', 'Ddx3y', 'Eif2s3y', 'Tsix', 'Uty', 'AC149090.1PC_ 1')]
VariableFeatures(sobject2) = var.genes
sobject2 <- ScaleData(object = sobject2, features = var.genes, vars.to.regress = c("S.Score", "G2M.Score","nCount_RNA","percent.mito"))

# Now, a PCA on the variable genes no longer returns components associated
# with cell cycle
sobject2 <- RunPCA(object = sobject2, features = var.genes, genes.print = 10)
PCAPlot(object = sobject2)
sobject2@reductions$UMAP<-NULL
sobject2<-RunUMAP(sobject2,reduction = "pca",dims = 1:30, verbose = F)
sobject2<-FindNeighbors(sobject2,dims=1:30,verbose=F)
set.seed(1)
sobject2<-FindClusters(sobject2,verbose=F,resolution = 0.5)

DimPlot(object = sobject2, pt.size=0.5, label=F)
DimPlot(object = sobject2, group.by="sample_description", pt.size=0.5)
DimPlot(object = sobject2, group.by="finalclusters", pt.size=0.5, label=T)
DimPlot(object = sobject2, group.by="sample_description",split.by = "finalclusters", pt.size=0.5,ncol = 3)

```


Barplot

```{r}
r = table(droplevels(sobject$finalclusters),sobject$fulldescription)
x = grep("P7",colnames(r))
r = r[,x]
#normalize to 1,000 cells per sample
Control_female = (r[,1]/colSums(r)[1])*2000
Deprived_female = (r[,3]/colSums(r)[3])*2000

Control_male = (r[,2]/colSums(r)[2])*2000
Deprived_male = (r[,4]/colSums(r)[4])*2000

rf = cbind(Control_female,Deprived_female)
rf = cbind(rf,total = rowSums(rf))

rm = cbind(Control_male,Deprived_male)
rm = cbind(rm,total = rowSums(rm))

rc = cbind(Control_P5,Control_P7)
rc = cbind(rc,total = rowSums(rc))
#show a barplot with percent cells per cluster

cols5 = c("lightblue","pink")
cols7 = c("darkblue","red3")
colsc = c("lightblue","darkblue")
r1 = rm
for (row in 1:nrow(r1)){
  r1[row,] = r1[row,]/r1[row,ncol(r1)]*100
  r1
}
r1 = r1[,1:2]
relconpct = t(r1)
cols = cols7
setEPS()
postscript("~/Desktop/3H_control.eps")
barplot(relconpct, main="Cluster composition by percent of celltype",
        xlab="Cluster", ylab = "% of cluster", ylim = c(0,100), col=cols,axisnames = T,
        width = .2,xlim = c(0,5),legend = rownames(relconpct), space = 0.6,cex.names = 0.8,axis.lty = 1)
dev.off()
```

 Contingency tables for barplots. Note that this makes more sense if done with only 2 samples, as only one statistic will be calculated per cluster. 
 
```{r}
clustercolumn = "seurat_clusters"
samplecolumn = "age"


all = table(sobject[[clustercolumn]][,1],sobject[[samplecolumn]][,1])

total = colSums(all)
clusters = rownames(all)
test = list()
chi = chisq.test(all)


for (cluster in clusters){
  x = rbind(all[cluster,],total-all[cluster,])
  rownames(x) = c(cluster,"total")
  chi = chisq.test(x)
  f = sqrt(chi$statistic/sum(x))
  test[[cluster]] = chi
  test[[cluster]]$f = f
}

#print out the p-value and cramer's v (closer to 1 = higher effect size) for each cluster
for (cluster in clusters){
  print(cluster)
  print(test[[cluster]]$p.value) #p-value
  print(sqrt(test[[cluster]]$statistic/sum(all[cluster,]))) #normalized by the number of cells in the cluster = cramer's v
}
```
 

